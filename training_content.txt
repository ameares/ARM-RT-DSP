Training Context File

I have a C function abs_sat_q31.  Can you make me a CUnit test for it?  I need all the information about how to set it up and run it.

/**
 * \brief A 16-bit fractional data type in 1.15 format.
 * The most significant bit is the sign bit.
 */
typedef int16_t q15_t;

/**
 * \brief A 32-bit fractional data type in 1.31 format.
 * The most significant bit is the sign bit.
 */
typedef int32_t q31_t;

/**
 * \brief Calculates the absolute value of the input with saturation.
 *
 * \param parVal The input value.
 * \return The absolute value of the input saturated to [1.0, 1.0).
 */
static inline q31_t abs_sat_q31(q31_t parVal)
{
    int32_t wResult;

    /* Take opposite of value and test value in the process */
    wResult = -parVal;

    if (wResult < 0)
    {
        /* result is negative, that means :
        - parVal is positive : following operation will subtract 0 to parVal
        - parVal is 0x80000000 : following operation will subtract 1 to parVal => 0x7FFFFFFF */
        wResult = parVal - (((uint32_t)parVal) >> 31);
    }
    /* else result is positive, that means that parVal is negative, nothing else to do */
    return wResult;
}


Now add CUnit tests for the following functions.  Just show me the code that needs changing.

/**
 * \brief   Signed Saturate
 * \details Saturates a signed value.
 * \param [in]  value  Value to be saturated
 * \param [in]    sat  Bit position to saturate to (1..32)
 * \return             Saturated value
 */
static inline int64_t ssat_i64(int64_t val, uint32_t sat)
{
  if ((sat >= 1U) && (sat <= 64U))
  {
    const int64_t max = (int64_t)((1U << (sat - 1U)) - 1U);
    const int64_t min = -1 - max ;
    if (val > max)
    {
      return max;
    }
    else if (val < min)
    {
      return min;
    }
  }
  return val;
}


/**
 * \brief Calculates the absolute value of the input without saturation.
 *
 * \param parVal The input value.
 * \return The absolute value of the input in the range [1.0, 1.0).
 */
static inline q31_t abs_q31(q31_t parVal)
{
    if (parVal < 0) {
        return -parVal;
    } else {
        return parVal;
    }
}


/**
 * \brief Multiplies two Q15s with saturation.
 *
 * Some of these capabilities are captured in the toolchain's intrinsics or "idioms".
 * \todo Make a rounding version.
 * \param x The first multiplicand.
 * \param y The second multiplicand.
 * \return The saturated product of the two multiplicands with a range of [-1.0, 1.0).
 */
static inline q15_t mulsat_q15(q15_t x, q15_t y) {
    q31_t out;
    out = ((q31_t) x * y) >> 16;
    out = __SSAT(out, 15);
    return out << 1U;
}


/**
 * \brief Multiplies two Q31s with saturation.
 *
 * The saturated version sacrifices the lowest bit.
 *
 * \todo Make a rounding version.
 * \param x The first multiplicand.
 * \param y The second multiplicand.
 * \return The saturated product of the two multiplicands with a range of [-1.0, 1.0).
 */
static inline q31_t mulsat_q31(q31_t x, q31_t y) {
    q31_t out;
    out = ((q63_t) x * y) >> 32;
    out = __SSAT(out, 31);
    // I am still playing around with the finer points of DSP operations. AM 2/15/21
    return out << 1U;
}


void test_function_name() {
    // Initialize your test variables and inputs here
    // Call the function you want to test and check its output.
    // Prepare inputs.
    CU_ASSERT(function_name(input1) == expected_output1);
    // Prepare more inputs.
    CU_ASSERT_EQUAL(function_name(input2), expected_output2);
    // Add more assertions or complex logic as needed.
}


void test_add() {
    // Arrange
    int a = 5;
    int b = 3;

    // Act
    int result = add(a, b);

    // Assert
    CU_ASSERT_EQUAL(result, 8);
}





You are a code developer and you write C code for CUnit tests.  The user will give you a function prototype, 
possibly with a comment describing its use, possibly with the definition of the function attached.  Respond 
only with a CUnit test in C code.  Use comments to embed any explanation in the code.  Use the template and 
the included header code to help guide your response.  If the information included does not provide complete 
test coverage, include a comment as a placeholder to add more test cases.  Only respond with the test 
function and any newly created sub-functions.  Do not include the header code or the template.  Try to use 
an array to hold test data and iterate over it, when that makes sense.

TEMPLATE:
void test_function_name() {
    // Initialize your test variables and inputs here
    // Call the function you want to test and check its output.
    // Prepare inputs.
    // Make calls to CU_ASSERT or CU_ASSERT_EQUAL.
    // Add more assertions or complex logic as needed.
}

HEADER CODE:
#include <stdint.h>

/**
 * \brief A 16-bit fractional data type in 1.15 format.
 * 
 * The most significant bit is the sign bit.
 */
typedef int16_t q15_t;

/**
 * \brief A 32-bit fractional data type in 1.31 format.
 * 
 * The most significant bit is the sign bit.
 */
typedef int32_t q31_t;

/**
 * \brief A 64-bit fractional data type in 1.63 format.
 * 
 * The most significant bit is the sign bit.
 */
typedef int64_t q63_t;

/** \brief Macro for defining a q15_t constant value in the range [-1.0, 1.0). */
#define Q15(x) ((q15_t)((x) < 0.999969482421875 ? ((x) >= -1 ? (x)*0x8000 : 0x8000) : 0x7FFF))

/** \brief Macro for defining a q31_t constant value in the range [-1.0, 1.0). */
#define Q31(x) ((q31_t)((x) < 1 ? ((x) >= -1 ? (x)*0x80000000 : 0x80000000) : 0x7FFFFFFF))