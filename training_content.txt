Training Context File

/////////////////////////////////////

I want to work on my Github project today.  This is an 
embedded C project that uses CUnit for unit testing.  The 
project consists of ARM DSP library that I am adding unit
tests to and publishing to GitHub.  I would like to make 
improvements as I go along.  I need to add CUnit tests 
for my new ramp functions.  Please repeat the plan back to me.
without writing any code or explaining much.

Here is a list of the files in the repository:
ARM-RT-DSP/Makefile
ARM-RT-DSP/docs/usage_guide.md
ARM-RT-DSP/docs/api_reference.md
ARM-RT-DSP/tests/suite1.c
ARM-RT-DSP/tests/test_main.c
ARM-RT-DSP/include/arm_rt_dsp.h
ARM-RT-DSP/include/common.h
ARM-RT-DSP/src/arm_rt_dsp.c
ARM-RT-DSP/training_content.txt
ARM-RT-DSP/README.md
ARM-RT-DSP/LICENSE.txt

Here is my status journal for the project:
5/20 - Added custom ramp functions to the arm_rt_dsp.h file.
5/20 - Added custom ramp functions to the arm_rt_dsp.c file.
5/20 - Removed old commented out code and unrelevant comments.
5/20 - Investigated running automated unit tests on ARM development boards.
5/19 - Published ARM-RT-DSP to Github private repository and connected the VS Code project.
5/17 - Added some of my custome DSP types and functions to the arm_rt_dsp.h file.
5/16 - Added arm_rt_dsp.h and common.h to the project.
5/15 - Created ARM-RT-DSP project in VS Code and added CUnit unit tests.

Here is my plan for today:
1. Add CUnit tests for the new ramp functions.


Here is the code for a ramp function.  Write a CUnit test.  I will add this to a new file, suite2.c.  Use an array for the test inputs.

void ramp_limit_init_i16(int16_t y0, ramp_limit_i16_t *r) {
    // Sets the starting value to between the lower limit and the upper limit.
    if (y0 < r->llim) {
        r->y = r->llim;
    } else if (y0 > r->ulim) {
        r->y = r->ulim;
    } else {
        r->y = y0;
    }
}


int16_t ramp_limit_i16(int16_t x, ramp_limit_i16_t *r) {
    int32_t delta = 0;

    delta = x - r->y;

    // inc is the limit of speed of movement from one number to the next.
    // Lets just do this the verbose way first.
    if (delta > r->inc) {
        delta = r->inc;
    } else if (delta < (0-r->inc)) {
        delta = 0 - r->inc;
    }

    r->y += delta;

    // Sets the return value to between the lower limit and the upper limit.
    if (r->y < r->llim) {
        r->y = r->llim;
    } else if (r->y > r->ulim) {
        r->y = r->ulim;
    }

    return r->y;
}

















Lets review some functions in arm_rt_dsp.h.  While we review these functions, please ask for any further information you need.  For example, if the q31_t type is not defined, stop the output and ask please give the q31_t definition.

/**
 * \brief Multiplies two Q31s.
 *
 * \param x The first multiplicand.
 * \param y The second multiplicand.
 * \return The product of the two multiplicands.
 */
static inline q31_t mul_q31(q31_t x, q31_t y) {
    q31_t out;
    out = ((q63_t) x * y) >> 31;
    //out = __SSAT(out, 31);
    // I am still playing around with the finer points of DSP operations. AM 2/15/21
    return out; // << 1U;
}


Here are some common type definitions from the top of arm_rt_dsp.h.  Please continue to ask for information that is needed.

/**
 * \brief A 16-bit fractional data type in 1.15 format.
 * 
 * The most significant bit is the sign bit.
 */
typedef int16_t q15_t;

/**
 * \brief A 32-bit fractional data type in 1.31 format.
 * 
 * The most significant bit is the sign bit.
 */
typedef int32_t q31_t;

/**
 * \brief A 64-bit fractional data type in 1.63 format.
 * 
 * The most significant bit is the sign bit.
 */
typedef int64_t q63_t;

/**
 * \brief A 16-bit accumulator data type in 9.7 format.
 *
 * In order to stay consistent with the ARM DSP Q types, the sign bit is not
 * counted.
 */
typedef int16_t acc15_t;

/**
 * \brief A 32-bit accumulator data type in 17.15 format.
 *
 * In order to stay consistent with the ARM DSP Q types, the sign bit is not counted.
 *
 * Does this name even make sense.  Maybe acc32_t was better or acc17_15_t or anything. AM
 */
typedef int32_t acc31_t;

/**
 * \brief A 64-bit accumulator in 33.31 format.
 *
 * In order to stay consistent with the ARM DSP Q types, the sign bit is not counted.
 */
typedef int64_t acc63_t;







Running your unit tests on actual hardware using a fleet of development boards can provide valuable insights into the real-world behavior and performance of your code. To set up such a system with automatic deployment and Grafana for test result visualization, here's a high-level approach you can follow:

Choose the development boards: Research and select the development boards that best suit your project requirements. Ensure that they support the ARM architecture and have the necessary capabilities for running your code and unit tests. Popular options include Raspberry Pi, BeagleBone, or custom ARM-based boards.

Setup the testing environment: Set up the testing environment for each development board. This includes installing the necessary dependencies, compilers, and any specific libraries or toolchains required for your project.

Automate deployment: Establish an automated deployment process to deploy your code and unit tests to the development boards. You can use configuration management tools like Ansible, Puppet, or custom scripts to manage the deployment process. These tools help ensure consistent configurations across multiple boards and simplify the deployment workflow.

Implement test automation: Develop an automated testing framework that runs your unit tests on the deployed development boards. You can use test frameworks such as CUnit or frameworks specific to your development boards' ecosystem (e.g., Raspberry Pi's RPi.GPIO library). Write test scripts that execute your unit tests and capture the results.

Collect and analyze test results: Integrate the test framework with a logging and visualization system like Grafana. Configure the test framework to log test results in a format that can be consumed by Grafana (e.g., exporting to a time-series database). Set up dashboards in Grafana to display relevant metrics and performance data from the test results. This allows you to monitor and analyze the test outcomes across the fleet of development boards.

Monitor and manage the test fleet: Implement a monitoring system to track the health and availability of the development boards. This can be done using tools like Nagios, Zabbix, or custom monitoring scripts. Monitor critical parameters like CPU usage, memory consumption, and connectivity status to ensure the test fleet is operating properly.

Continuous Integration/Continuous Deployment (CI/CD): Integrate the automated testing system with a CI/CD platform like Jenkins, GitLab CI/CD, or GitHub Actions. This allows you to trigger the deployment and testing process automatically whenever new code changes are pushed to your repository. The CI/CD pipeline can handle building, deploying, and executing tests across the development boards, providing an efficient and streamlined development workflow.

Scale and manage the fleet: As your project grows, you can scale up the fleet of development boards by adding more boards to the testing system. Use tools and automation techniques to manage the fleet efficiently, such as provisioning, monitoring, and remote management tools.

By following this approach, you can create an automated testing infrastructure that deploys your code to a fleet of development boards, executes unit tests, and visualizes the test results using Grafana. This system provides a comprehensive and scalable solution for running tests on real hardware and monitoring the performance of your code.

Remember to regularly monitor and maintain the testing infrastructure, ensuring that it remains up to date with the latest software versions and hardware configurations for accurate and reliable testing.
















I have a C function abs_sat_q31.  Can you make me a CUnit test for it?  I need all the information about how to set it up and run it.

/**
 * \brief A 16-bit fractional data type in 1.15 format.
 * The most significant bit is the sign bit.
 */
typedef int16_t q15_t;

/**
 * \brief A 32-bit fractional data type in 1.31 format.
 * The most significant bit is the sign bit.
 */
typedef int32_t q31_t;

/**
 * \brief Calculates the absolute value of the input with saturation.
 *
 * \param parVal The input value.
 * \return The absolute value of the input saturated to [1.0, 1.0).
 */
static inline q31_t abs_sat_q31(q31_t parVal)
{
    int32_t wResult;

    /* Take opposite of value and test value in the process */
    wResult = -parVal;

    if (wResult < 0)
    {
        /* result is negative, that means :
        - parVal is positive : following operation will subtract 0 to parVal
        - parVal is 0x80000000 : following operation will subtract 1 to parVal => 0x7FFFFFFF */
        wResult = parVal - (((uint32_t)parVal) >> 31);
    }
    /* else result is positive, that means that parVal is negative, nothing else to do */
    return wResult;
}


Now add CUnit tests for the following functions.  Just show me the code that needs changing.

/**
 * \brief   Signed Saturate
 * \details Saturates a signed value.
 * \param [in]  value  Value to be saturated
 * \param [in]    sat  Bit position to saturate to (1..32)
 * \return             Saturated value
 */
static inline int64_t ssat_i64(int64_t val, uint32_t sat)
{
  if ((sat >= 1U) && (sat <= 64U))
  {
    const int64_t max = (int64_t)((1U << (sat - 1U)) - 1U);
    const int64_t min = -1 - max ;
    if (val > max)
    {
      return max;
    }
    else if (val < min)
    {
      return min;
    }
  }
  return val;
}


/**
 * \brief Calculates the absolute value of the input without saturation.
 *
 * \param parVal The input value.
 * \return The absolute value of the input in the range [1.0, 1.0).
 */
static inline q31_t abs_q31(q31_t parVal)
{
    if (parVal < 0) {
        return -parVal;
    } else {
        return parVal;
    }
}


/**
 * \brief Multiplies two Q15s with saturation.
 *
 * Some of these capabilities are captured in the toolchain's intrinsics or "idioms".
 * \todo Make a rounding version.
 * \param x The first multiplicand.
 * \param y The second multiplicand.
 * \return The saturated product of the two multiplicands with a range of [-1.0, 1.0).
 */
static inline q15_t mulsat_q15(q15_t x, q15_t y) {
    q31_t out;
    out = ((q31_t) x * y) >> 16;
    out = __SSAT(out, 15);
    return out << 1U;
}


/**
 * \brief Multiplies two Q31s with saturation.
 *
 * The saturated version sacrifices the lowest bit.
 *
 * \todo Make a rounding version.
 * \param x The first multiplicand.
 * \param y The second multiplicand.
 * \return The saturated product of the two multiplicands with a range of [-1.0, 1.0).
 */
static inline q31_t mulsat_q31(q31_t x, q31_t y) {
    q31_t out;
    out = ((q63_t) x * y) >> 32;
    out = __SSAT(out, 31);
    // I am still playing around with the finer points of DSP operations. AM 2/15/21
    return out << 1U;
}


void test_function_name() {
    // Initialize your test variables and inputs here
    // Call the function you want to test and check its output.
    // Prepare inputs.
    CU_ASSERT(function_name(input1) == expected_output1);
    // Prepare more inputs.
    CU_ASSERT_EQUAL(function_name(input2), expected_output2);
    // Add more assertions or complex logic as needed.
}


void test_add() {
    // Arrange
    int a = 5;
    int b = 3;

    // Act
    int result = add(a, b);

    // Assert
    CU_ASSERT_EQUAL(result, 8);
}





You are a code developer and you write C code for CUnit tests.  The user will give you a function prototype, 
possibly with a comment describing its use, possibly with the definition of the function attached.  Respond 
only with a CUnit test in C code.  Use comments to embed any explanation in the code.  Use the template and 
the included header code to help guide your response.  If the information included does not provide complete 
test coverage, include a comment as a placeholder to add more test cases.  Only respond with the test 
function and any newly created sub-functions.  Do not include the header code or the template.  Try to use 
an array to hold test data and iterate over it, when that makes sense.

TEMPLATE:
void test_function_name() {
    // Initialize your test variables and inputs here
    // Call the function you want to test and check its output.
    // Prepare inputs.
    // Make calls to CU_ASSERT or CU_ASSERT_EQUAL.
    // Add more assertions or complex logic as needed.
}

HEADER CODE:
#include <stdint.h>

/**
 * \brief A 16-bit fractional data type in 1.15 format.
 * 
 * The most significant bit is the sign bit.
 */
typedef int16_t q15_t;

/**
 * \brief A 32-bit fractional data type in 1.31 format.
 * 
 * The most significant bit is the sign bit.
 */
typedef int32_t q31_t;

/**
 * \brief A 64-bit fractional data type in 1.63 format.
 * 
 * The most significant bit is the sign bit.
 */
typedef int64_t q63_t;

/** \brief Macro for defining a q15_t constant value in the range [-1.0, 1.0). */
#define Q15(x) ((q15_t)((x) < 0.999969482421875 ? ((x) >= -1 ? (x)*0x8000 : 0x8000) : 0x7FFF))

/** \brief Macro for defining a q31_t constant value in the range [-1.0, 1.0). */
#define Q31(x) ((q31_t)((x) < 1 ? ((x) >= -1 ? (x)*0x80000000 : 0x80000000) : 0x7FFFFFFF))


Here is my makefile.  Please make it so that the object files are compiled in a separate directory from the source code files.

MAKEFILE:

CC := gcc
CFLAGS := -Wall -Wextra -std=c11 -I./include
LIBS := -lcunit

# Directories
SRC_DIR := src
TEST_DIR := tests

# Source and test files
SOURCES := $(wildcard $(SRC_DIR)/*.c)
TESTS := $(wildcard $(TEST_DIR)/*.c)

# Object files
OBJECTS := $(SOURCES:.c=.o)
TEST_OBJECTS := $(TESTS:.c=.o)

# Executables
EXECUTABLE := arm_rt_dsp
TEST_EXECUTABLE := rt_dsp_test_runner

.PHONY: all clean test

all: $(EXECUTABLE)

# Build the main library
$(EXECUTABLE): $(OBJECTS)
	$(CC) $(CFLAGS) $^ -o $@

# Build the test runner
$(TEST_EXECUTABLE): $(TEST_OBJECTS)
	$(CC) $(CFLAGS) $^ -o $@ $(LIBS)

# Rule for building object files
%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

# Run the tests
test: $(TEST_EXECUTABLE)
	./$(TEST_EXECUTABLE)

clean:
	rm -f $(OBJECTS) $(TEST_OBJECTS) $(EXECUTABLE) $(TEST_EXECUTABLE)